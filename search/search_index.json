{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Xyndril Documentation","text":"<p>Welcome to the documentation of the Xyndril programming language!</p> <ul> <li>Usage</li> <li>Manifest</li> <li>Workspace Setup</li> </ul>"},{"location":"language-spec/","title":"Xyndril Language Specification","text":"<p>See xyndril-manifest.md for the full manifest and language details.</p> <p>This file can be expanded with highlights or summaries of the language for quick reference.</p>"},{"location":"parser_spec/","title":"Xyndril Parser Specification","text":"<p>This document specifies the syntax for the Xyndril language and how the parser should recognize language constructs.</p>"},{"location":"parser_spec/#1-general-syntax","title":"1. General Syntax","text":"<p>Xyndril uses a C-style syntax with curly braces, semicolons, and common operators. The language is designed to be familiar to developers with experience in JavaScript, TypeScript, and similar languages while incorporating unique features for full-stack development.</p>"},{"location":"parser_spec/#2-lexical-structure","title":"2. Lexical Structure","text":""},{"location":"parser_spec/#21-comments","title":"2.1 Comments","text":"<pre><code>// Single-line comment\n\n/* \n   Multi-line\n   comment\n*/\n</code></pre>"},{"location":"parser_spec/#22-literals","title":"2.2 Literals","text":"<pre><code>// Numbers\n42         // Integer\n3.14       // Float\n\n// Strings\n\"hello\"    // Double quotes\n'world'    // Single quotes\n`template ${expression}` // Template string with interpolation\n\n// Booleans\ntrue\nfalse\n\n// Null and undefined\nnull\nundefined\n</code></pre>"},{"location":"parser_spec/#23-identifiers","title":"2.3 Identifiers","text":"<p>Identifiers start with a letter or underscore, followed by any number of letters, digits, or underscores.</p> <pre><code>variableName\n_privateVar\n$element\n</code></pre>"},{"location":"parser_spec/#3-language-constructs","title":"3. Language Constructs","text":""},{"location":"parser_spec/#31-variable-declarations-with-let","title":"3.1 Variable Declarations with <code>let</code>","text":"<pre><code>// Simple declaration\nlet name;\n\n// With initialization\nlet age = 30;\n\n// With type annotation\nlet email: String = \"user@example.com\";\n\n// Multiple declarations\nlet x = 1, y = 2;\n</code></pre> <p>The parser should recognize: - The <code>let</code> keyword - An identifier - Optional type annotation (<code>: TypeName</code>) - Optional initializer (<code>= expression</code>) - Multiple declarations separated by commas</p>"},{"location":"parser_spec/#32-if-statements","title":"3.2 If Statements","text":"<pre><code>// Basic if\nif (condition) {\n  // statements\n}\n\n// If-else\nif (condition) {\n  // statements\n} else {\n  // statements\n}\n\n// If-else if-else\nif (condition1) {\n  // statements\n} else if (condition2) {\n  // statements\n} else {\n  // statements\n}\n</code></pre> <p>The parser should recognize: - The <code>if</code> keyword - A parenthesized condition expression - A block statement for the \"then\" branch - Optional <code>else</code> keyword followed by a block statement or another if statement</p>"},{"location":"parser_spec/#33-arrow-functions","title":"3.3 Arrow Functions","text":"<pre><code>// Simple arrow function\nlet add = (a, b) =&gt; a + b;\n\n// Multi-line arrow function with block\nlet greet = (name) =&gt; {\n  return `Hello, ${name}!`;\n};\n\n// With type annotations\nlet multiply = (x: Number, y: Number): Number =&gt; x * y;\n\n// No parameters\nlet sayHello = () =&gt; \"Hello!\";\n</code></pre> <p>The parser should recognize: - A parameter list (possibly empty) in parentheses - Optional type annotations for parameters - The arrow (<code>=&gt;</code>) token - An expression or block statement for the function body - Optional return type annotation after the parameter list</p>"},{"location":"parser_spec/#34-classes","title":"3.4 Classes","text":"<pre><code>class User {\n  // Properties with type annotations\n  name: String\n  email: String\n  age: Number\n\n  // Constructor\n  constructor(name, email, age) {\n    this.name = name\n    this.email = email\n    this.age = age\n  }\n\n  // Method with return type\n  greet() -&gt; String {\n    return `Hello, I'm ${this.name}!`\n  }\n\n  // Method with parameters\n  updateEmail(newEmail: String) {\n    this.email = newEmail\n  }\n}\n</code></pre> <p>The parser should recognize: - The <code>class</code> keyword followed by an identifier - A class body enclosed in curly braces - Property declarations with optional type annotations - Method declarations with an identifier, parameter list, optional return type, and block body - A special <code>constructor</code> method</p>"},{"location":"parser_spec/#35-rest-routes","title":"3.5 REST Routes","text":"<pre><code>route GET /users {\n  // Return all users\n  return db.getUsers()\n}\n\nroute POST /users {\n  // Create a new user\n  return db.createUser(request.body)\n}\n\nroute GET /users/:id {\n  // Get a specific user\n  return db.getUser(params.id)\n}\n\n// Routes inside classes\nclass UserController {\n  route GET /api/users {\n    return this.getAllUsers()\n  }\n\n  getAllUsers() {\n    // Implementation\n  }\n}\n</code></pre> <p>The parser should recognize: - The <code>route</code> keyword - HTTP method (GET, POST, PUT, DELETE, etc.) - URL path with optional parameters (prefixed with <code>:</code>) - Block body for route handler</p>"},{"location":"parser_spec/#4-expressions","title":"4. Expressions","text":""},{"location":"parser_spec/#41-binary-operators","title":"4.1 Binary Operators","text":"<p>Standard arithmetic, comparison, and logical operators:</p> <pre><code>// Arithmetic\na + b\na - b\na * b\na / b\na % b\n\n// Comparison\na == b\na != b\na &lt; b\na &lt;= b\na &gt; b\na &gt;= b\n\n// Logical\na &amp;&amp; b\na || b\n</code></pre>"},{"location":"parser_spec/#42-unary-operators","title":"4.2 Unary Operators","text":"<pre><code>-a      // Negation\n!a      // Logical NOT\na++     // Increment\na--     // Decrement\n</code></pre>"},{"location":"parser_spec/#43-function-calls","title":"4.3 Function Calls","text":"<pre><code>print(\"Hello\")\nuser.getName()\nMath.max(1, 2, 3)\n</code></pre>"},{"location":"parser_spec/#44-member-access","title":"4.4 Member Access","text":"<pre><code>user.name\narray[0]\n</code></pre>"},{"location":"parser_spec/#5-statements","title":"5. Statements","text":""},{"location":"parser_spec/#51-return-statements","title":"5.1 Return Statements","text":"<pre><code>return;\nreturn value;\n</code></pre>"},{"location":"parser_spec/#52-expression-statements","title":"5.2 Expression Statements","text":"<p>Any expression can be used as a statement:</p> <pre><code>foo();\na = b + c;\nx++;\n</code></pre>"},{"location":"parser_spec/#6-program-structure","title":"6. Program Structure","text":"<p>A Xyndril program consists of a sequence of statements and declarations at the top level:</p> <pre><code>// Imports (future feature)\nimport { Component } from 'library'\n\n// Variable declarations\nlet config = {\n  port: 3000\n}\n\n// Function declarations\nlet start = () =&gt; {\n  // Implementation\n}\n\n// Class declarations\nclass App {\n  // Implementation\n}\n\n// Route declarations\nroute GET / {\n  return \"Hello, World!\"\n}\n\n// Main code\nstart()\n</code></pre>"},{"location":"parser_spec/#7-parsing-strategy","title":"7. Parsing Strategy","text":"<p>The parser should follow these steps:</p> <ol> <li>Tokenize the input into a stream of tokens</li> <li>Build a recursive descent parser that recognizes the language constructs</li> <li>Construct an AST according to the structure defined in <code>ast.cld.py</code></li> <li>Handle error cases with informative error messages</li> </ol> <p>The parser should be designed to be extensible for future language features.</p>"},{"location":"usage/","title":"Xyndril Usage Guide","text":"<p>This section will contain instructions for using the Xyndril language and its tools.</p>"},{"location":"workspace-setup/","title":"Workspace Setup","text":"<p>This page describes how to set up the Xyndril programming language development environment.</p>"},{"location":"workspace-setup/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10+</li> <li>Git</li> <li>(Optional) VS Code or Windsurf Editor</li> </ul>"},{"location":"workspace-setup/#installation","title":"Installation","text":"<ol> <li>Clone the repository:    <code>sh    git clone https://github.com/maaninentupee/xyndril-kit.git    cd xyndril-kit</code></li> <li>Create and activate a virtual environment:    <code>sh    python3 -m venv .venv    source .venv/bin/activate</code></li> <li>Install dependencies:    <code>sh    pip install -r requirements.txt</code></li> </ol>"},{"location":"workspace-setup/#running-the-documentation-site","title":"Running the Documentation Site","text":"<p>To preview the documentation locally:</p> <pre><code>mkdocs serve\n</code></pre> <p>Site will be available at http://localhost:8000</p>"},{"location":"workspace-setup/#notes","title":"Notes","text":"<ul> <li>Only files in the <code>docs/</code> folder are published to the documentation site.</li> <li>Do not edit or move files in <code>design/</code>, <code>parser/</code>, or <code>ohjeet.txt</code> unless instructed.</li> </ul>"},{"location":"xyndril-manifest/","title":"Xyndril Manifest (Technical Vision)","text":""},{"location":"xyndril-manifest/#what-is-xyndril","title":"\u2728 What is Xyndril?","text":"<p>Xyndril is an experimental full-stack programming language designed to unify frontend, backend, and AI logic into a seamless development experience.</p> <p>Unlike traditional stacks where developers must switch between multiple languages and tools (JavaScript, Python, OpenAI SDKs), Xyndril proposes a single-language architecture that eliminates friction between layers.</p>"},{"location":"xyndril-manifest/#philosophy","title":"\ud83d\udd20 Philosophy","text":"<ul> <li>\"One language to rule every layer\"</li> <li>Readable and extensible syntax</li> <li>Lightweight typing with optional static types</li> <li>AI features embedded into the language core</li> <li>Native support for API routing and UI components</li> </ul>"},{"location":"xyndril-manifest/#key-differentiators","title":"\ud83d\udca1 Key Differentiators","text":"Feature Xyndril Other Languages Full-stack support \u2705 One syntax for all layers \u274c Separated frontend/backend AI integration \u2705 Native in syntax \u274c Requires external libs REST routes \u2705 Part of the language \u274c Defined in framework UI components \u2705 (planned) native syntax \u274c Framework-specific"},{"location":"xyndril-manifest/#version-001-features","title":"\ud83d\ude80 Version 0.0.1 Features","text":"<ul> <li><code>print()</code> command</li> <li><code>class</code> keyword for defining objects</li> <li><code>fn</code> for methods</li> <li><code>route GET /path =&gt; { ... }</code> \u2014 native REST routing</li> <li><code>let</code> statements</li> <li>Arrow functions: <code>let add = (a, b) =&gt; a + b</code></li> <li>Conditional logic with <code>if/else</code></li> <li>\u2728 AI Command: <code>ai.prompt(\"...\")</code> (planned v0.0.2)</li> </ul>"},{"location":"xyndril-manifest/#syntax-example","title":"\ud83d\udd22 Syntax Example","text":"<pre><code>// Class definition\nclass User {\n  name: String\n  email: String\n  age: Number\n\n  constructor(name, email, age) {\n    this.name = name\n    this.email = email\n    this.age = age\n  }\n\n  greet() -&gt; String {\n    return \"Hello, I'm ${this.name}!\"\n  }\n\n  route GET /user/:id {\n    return this\n  }\n}\n\n// Functional style\nlet double = (x: Number) -&gt; Number =&gt; x * 2\nlet add = (a, b) =&gt; a + b\n\n// Conditional logic\nif (user.age &gt;= 18) {\n  console.log(\"Adult\")\n} else {\n  console.log(\"Minor\")\n}\n\n// Higher-order functions\nlet adults = users\n  .filter(user =&gt; user.age &gt;= 18)\n  .map(user =&gt; user.name)\n</code></pre>"},{"location":"xyndril-manifest/#runtime-architecture-planned","title":"\ud83d\udea7 Runtime Architecture (Planned)","text":""},{"location":"xyndril-manifest/#memory-management","title":"Memory Management:","text":"<ul> <li>Static analysis of variables at compile time</li> <li>Stack allocation for primitives</li> <li>Heap with generational GC for complex types</li> <li>Region-based memory zones for task-specific speed</li> </ul>"},{"location":"xyndril-manifest/#garbage-collection-strategy","title":"Garbage Collection Strategy:","text":"<ul> <li>Generational GC</li> <li>Concurrent execution</li> <li>Incremental marking</li> <li>Region-based optimization</li> </ul>"},{"location":"xyndril-manifest/#state-synchronization","title":"State Synchronization:","text":"<ul> <li>Realtime sync between client and server</li> <li>Reactive dataflow model planned</li> </ul>"},{"location":"xyndril-manifest/#vision","title":"\ud83c\udf0d Vision","text":"<p>Xyndril is not just a new syntax. It is an attempt to create a cohesive, AI-native programming world where API logic, UI elements, and AI behavior are written in one language.</p> <p>One language. One stack. Total fusion.</p>"},{"location":"xyndril-manifest/#technical-spec-roadmap","title":"\ud83d\udcda Technical Spec Roadmap","text":"Design Files (Claude) Refactored Code (GPT) <code>design/ast.cld.py</code> \u2192 <code>src/ast.py</code> <code>design/interpreter.cld.py</code> \u2192 <code>src/interpreter.py</code> <code>design/parser_spec.md</code> \u2192 <code>parser/xyndril.g4</code> (REPL Design) \u2192 <code>src/repl.py</code> <p>Design files are used as a planning layer, and refactoring is done by GPT for final integration into the compiler.</p>"},{"location":"xyndril-manifest/#see-also","title":"\ud83d\udd0d See Also","text":"<ul> <li>GitHub Repository</li> <li>\ud83d\udcd6 See the full project overview in the README on GitHub</li> </ul>"}]}