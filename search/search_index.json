{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Xyndril","text":"<p>Xyndril is an experimental AI-native programming language for full-stack development, agent automation, and seamless backend\u2013frontend integration.</p> <p>This site hosts the official documentation for the language, tools, and runtime components.</p>"},{"location":"#start-here","title":"\ud83d\ude80 Start Here","text":"<p>\ud83d\udcc4 Xyndril Manifest (Technical Vision) \ud83e\udde9 Parser Specification \ud83d\udee0\ufe0f Workspace Setup Guide</p>"},{"location":"#resources","title":"\ud83d\udd0d Resources","text":"<ul> <li>GitHub Repository </li> <li>Project README </li> <li>Docs Source</li> </ul>"},{"location":"#about-the-project","title":"\ud83d\udca1 About the Project","text":"<p>Xyndril unifies frontend, backend, and AI capabilities using a single cohesive syntax. It supports both stand-alone development and interoperability with other languages.</p>"},{"location":"language-spec/","title":"Xyndril Language Specification","text":""},{"location":"language-spec/#overview","title":"Overview","text":"<p>Xyndril is a modern, extensible programming language designed for clarity and expressiveness. Unlike monolithic languages, Xyndril is architected for interoperability: it is intended to be used alongside other programming languages in the same environment (polyglot). The language and its runtime are modular and extensible, making it possible to: - Call functions and use libraries from other languages (e.g. Python, JavaScript, etc.) within Xyndril code - Expose Xyndril modules and logic to be called from other languages - Integrate seamlessly in multi-language projects and runtimes (polyglot/interop) - Extend the language and runtime with new features, types, or backends without breaking compatibility</p> <p>This document describes Xyndril's syntax, semantics, and polyglot/interoperability goals, reflecting the current implementation and planned extensions.</p>"},{"location":"language-spec/#polyglot-interoperability","title":"Polyglot &amp; Interoperability","text":"<p>Xyndril is not a monolithic language. Its core design principles include: - Modularity: Language features, runtime, and standard library are implemented as modules that can be extended or replaced. - Interoperability: Xyndril supports calling and embedding code from other languages, and vice versa. - Extensibility: The parser and AST are designed to support new language constructs and foreign language integration. - Polyglot Environments: Xyndril can be embedded in, or extended to, polyglot runtimes (e.g., GraalVM, Python/C interop, etc.).</p>"},{"location":"language-spec/#example-use-cases","title":"Example Use Cases","text":"<ul> <li>Calling a Python function from Xyndril:   <code>xyndril   let result = py:math.sqrt(16);</code></li> <li>Embedding Xyndril logic in a Python application:   <code>python   from xyndril import evaluate   result = evaluate(\"let x = 42; x + 1;\")</code></li> <li>Creating a hybrid module that combines Xyndril and JavaScript logic</li> </ul>"},{"location":"language-spec/#syntax","title":"Syntax","text":""},{"location":"language-spec/#statements","title":"Statements","text":"<p>A Xyndril program consists of a sequence of statements, each terminated by a semicolon (<code>;</code>). Supported statement types: - Variable declaration: <code>let x = 42;</code>, <code>let y: Number = (x + 10) * 2;</code> - Assignment: <code>x = 42;</code> - Expression statement: <code>(x + 10) * 2;</code> - If statement:   <code>if (x &gt; 0) {     y = x;   } else {     y = -x;   }</code> - Return statement: <code>return;</code>, <code>return value;</code> - Class declaration, function/arrow function, and REST route definitions (see below)</p>"},{"location":"language-spec/#expressions","title":"Expressions","text":"<ul> <li>Literals: Numeric (<code>42</code>, <code>3.14</code>), string (<code>\"hello\"</code>), boolean (<code>true</code>, <code>false</code>), null (<code>null</code>).</li> <li>Variables: Identifiers (e.g., <code>x</code>, <code>myVar</code>).</li> <li>Binary Operations: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&amp;&amp;</code>, <code>||</code></li> <li>Unary Operations: <code>-a</code>, <code>!a</code></li> <li>Parentheses: For grouping, e.g., <code>(a + b) * c</code></li> <li>Function Calls: <code>foo(1, 2)</code>, <code>obj.method(arg)</code></li> <li>Member Access: <code>user.name</code>, <code>array[0]</code></li> <li>Arrow Functions: <code>(a, b) =&gt; a + b</code>, <code>(x: Number): Number =&gt; x * x</code></li> </ul>"},{"location":"language-spec/#variable-declarations","title":"Variable Declarations","text":"<ul> <li>Syntax: <code>let IDENTIFIER (: TypeName)? (= expr)? [,...];</code></li> <li>Examples:</li> <li><code>let x = 42;</code></li> <li><code>let y: Number;</code></li> <li><code>let a = 1, b: Number = 2;</code></li> </ul>"},{"location":"language-spec/#assignments","title":"Assignments","text":"<ul> <li>Syntax: <code>IDENTIFIER = expr;</code></li> <li>Example: <code>x = 42;</code>, <code>y = (10 + 20) * 2;</code></li> </ul>"},{"location":"language-spec/#functions","title":"Functions","text":"<ul> <li>Arrow function: <code>(a, b) =&gt; a + b;</code></li> <li>With block: <code>(x) =&gt; { return x * x; };</code></li> <li>With types: <code>(x: Number, y: Number): Number =&gt; x + y;</code></li> </ul>"},{"location":"language-spec/#classes","title":"Classes","text":"<pre><code>class User {\n  name: String;\n  email: String;\n  constructor(name, email) {\n    this.name = name;\n    this.email = email;\n  }\n  greet() -&gt; String {\n    return `Hello, I'm ${this.name}!`;\n  }\n}\n</code></pre>"},{"location":"language-spec/#rest-routes","title":"REST Routes","text":"<pre><code>route GET /users {\n  return db.getUsers();\n}\n</code></pre>"},{"location":"language-spec/#semantics","title":"Semantics","text":"<ul> <li>Evaluation:</li> <li>Literals evaluate to their value.</li> <li>Binary and unary operations are computed left-to-right.</li> <li>Variables evaluate to their value in the current scope.</li> <li>Assignments update variable values.</li> <li>Function calls evaluate arguments and invoke the function.</li> <li>Control flow: <code>if</code>, <code>while</code> (planned), etc.</li> <li>Error Handling:</li> <li>Division by zero, undefined variables, invalid operations, and type errors raise runtime errors with informative messages.</li> </ul>"},{"location":"language-spec/#example-program","title":"Example Program","text":"<pre><code>let x = 42;\nlet y = (x + 10) * 2;\nif (y &gt; 100) {\n  print(\"Large!\");\n} else {\n  print(\"Small!\");\n}\n</code></pre>"},{"location":"language-spec/#future-extensions","title":"Future Extensions","text":"<ul> <li>Control structures: <code>while</code>, <code>for</code>, pattern matching</li> <li>User-defined functions and lambdas</li> <li>Type system: integers, strings, booleans, optionals</li> <li>Modules and imports</li> <li>Enhanced error reporting and diagnostics</li> </ul>"},{"location":"language-spec/#synchronization-checklist","title":"Synchronization Checklist","text":"<ul> <li>[ ] Parser (<code>xyndril.g4</code>) matches this specification</li> <li>[ ] AST (<code>src/ast.py</code>) supports all constructs</li> <li>[ ] Interpreter executes all features</li> <li>[ ] Test suite covers new syntax and semantics</li> <li>[ ] Documentation (this file &amp; parser_spec.md) updated for all changes</li> </ul> <p>See xyndril-manifest.md for the full manifest and language details.</p> <p>See xyndril-manifest.md for the full manifest and language details.</p> <p>This file can be expanded with highlights or summaries of the language for quick reference.</p>"},{"location":"parser_spec/","title":"Xyndril Parser Specification","text":""},{"location":"parser_spec/#overview","title":"Overview","text":"<p>This document describes the design and logic of the Xyndril parser, implemented in <code>parser/parser.py</code> and defined by the ANTLR grammar (<code>xyndril.g4</code>).</p>"},{"location":"parser_spec/#polyglot-interoperability","title":"Polyglot &amp; Interoperability","text":"<p>The Xyndril parser and AST are designed for extensibility and interoperability: - The grammar is modular and can be extended to support new language constructs or foreign language embeddings. - AST nodes support hybrid constructs, allowing foreign function calls and type representations. - The parser is not monolithic; it is built to be embedded in polyglot runtimes and to parse/translate hybrid code that mixes Xyndril with other languages. - Future extensions will include grammar rules for foreign language blocks, imports, and interop expressions (e.g., <code>py:math.sqrt(16)</code> or embedding JavaScript blocks).</p> <p>This enables Xyndril to serve as a bridge language in multi-language projects, supporting seamless integration with Python, JavaScript, and other ecosystems.</p>"},{"location":"parser_spec/#parser-logic","title":"Parser Logic","text":"<p>The parser processes Xyndril source code as a sequence of statements and expressions, producing a structured AST for interpretation. Key features:</p>"},{"location":"parser_spec/#supported-statements-and-constructs","title":"Supported Statements and Constructs","text":"<ul> <li>Variable Declarations: <code>let x = 42;</code>, <code>let y: Number;</code>, <code>let a = 1, b: Number = 2;</code></li> <li>Assignments: <code>x = 42;</code></li> <li>If Statements: <code>if (cond) { ... } else { ... }</code></li> <li>Return Statements: <code>return;</code>, <code>return value;</code></li> <li>Class Declarations: <code>class User { ... }</code></li> <li>Arrow Functions: <code>(a, b) =&gt; a + b;</code></li> <li>REST Routes: <code>route GET /users { ... }</code></li> <li>Expression Statements: Any valid expression followed by <code>;</code></li> </ul>"},{"location":"parser_spec/#expressions","title":"Expressions","text":"<ul> <li>Literals: Numbers, strings, booleans, null</li> <li>Identifiers: Variable and function names</li> <li>Binary Operations: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&amp;&amp;</code>, <code>||</code></li> <li>Unary Operations: <code>-a</code>, <code>!a</code></li> <li>Function Calls: <code>foo(1, 2)</code>, <code>obj.method(arg)</code></li> <li>Member Access: <code>user.name</code>, <code>array[0]</code></li> <li>Parentheses: For grouping</li> <li>Arrow Functions: <code>(x, y) =&gt; x + y</code></li> </ul>"},{"location":"parser_spec/#grammar-structure-antlr-excerpt","title":"Grammar Structure (ANTLR excerpt)","text":"<pre><code>program: statement* EOF;\n\nstatement\n    : letStatement\n    | assignmentStatement\n    | ifStatement\n    | classDeclaration\n    | routeDefinition\n    | expressionStatement\n    ;\n\nletStatement: 'let' identifier (':' typeName)? ('=' expression)? (',' identifier (':' typeName)? ('=' expression)?)* ';';\nassignmentStatement: identifier '=' expression;\nifStatement: 'if' '(' expression ')' block ('else' (block | ifStatement))?;\nclassDeclaration: 'class' identifier classBody;\nrouteDefinition: 'route' httpMethod pathPattern block;\nexpressionStatement: expression ';';\n</code></pre>"},{"location":"parser_spec/#ast-structure","title":"AST Structure","text":"<p>The parser produces the following AST node types (see <code>src/ast.py</code>): - <code>Program</code> - <code>LetStatement</code>, <code>Assignment</code>, <code>IfStatement</code>, <code>ReturnStatement</code>, <code>ClassDeclaration</code>, <code>RouteDefinition</code>, <code>ExpressionStatement</code> - <code>Literal</code>, <code>Identifier</code>, <code>BinaryOperation</code>, <code>UnaryOperation</code>, <code>FunctionCall</code>, <code>MemberExpression</code>, <code>ArrowFunction</code> - <code>BlockStatement</code>, <code>PropertyDefinition</code>, <code>MethodDefinition</code>, <code>Parameter</code></p>"},{"location":"parser_spec/#example-ast-for-let-x-1-2-y","title":"Example AST (for <code>let x = (1 + 2) * y;</code>):","text":"<pre><code>LetStatement(\n  identifier=Identifier('x'),\n  initializer=BinaryOperation(\n    operator='*',\n    left=BinaryOperation('+', Literal(1), Literal(2)),\n    right=Identifier('y')\n  )\n)\n</code></pre>"},{"location":"parser_spec/#error-handling","title":"Error Handling","text":"<p>The parser uses a custom <code>SyntaxErrorListener</code> for immediate, informative syntax errors (e.g., missing semicolons, invalid tokens, mismatched types).</p>"},{"location":"parser_spec/#example","title":"Example","text":"<p>Input:</p> <pre><code>let x = 42;\nlet y = (x + 10) * 2;\nif (y &gt; 100) {\n  print(\"Large!\");\n} else {\n  print(\"Small!\");\n}\n</code></pre> <p>AST (pseudocode): - Program   - LetStatement(x, Literal(42))   - LetStatement(y, BinaryOperation('*', BinaryOperation('+', Identifier(x), Literal(10)), Literal(2)))   - IfStatement(       test=BinaryOperation('&gt;', Identifier(y), Literal(100)),       consequent=BlockStatement([...]),       alternate=BlockStatement([...])     )</p>"},{"location":"parser_spec/#future-extensions","title":"Future Extensions","text":"<ul> <li>Loops (<code>while</code>, <code>for</code>)</li> <li>User-defined functions</li> <li>Pattern matching</li> <li>Modules and imports</li> <li>Enhanced error diagnostics</li> </ul>"},{"location":"parser_spec/#synchronization-checklist","title":"Synchronization Checklist","text":"<ul> <li>[ ] Grammar (<code>xyndril.g4</code>) matches this specification</li> <li>[ ] AST (<code>src/ast.py</code>) supports all constructs</li> <li>[ ] Interpreter supports all grammar constructs</li> <li>[ ] Tests cover all features and edge cases</li> <li>[ ] Documentation (this &amp; language-spec.md) up to date</li> </ul>"},{"location":"parser_spec/#overview_1","title":"Overview","text":"<p>This document specifies the design and logic of the Xyndril language parser, implemented in <code>parser/parser.py</code>. The parser uses an ANTLR-based grammar (<code>xyndril.g4</code>) to parse expressions and constructs an Abstract Syntax Tree (AST) aligned with <code>src/ast.py</code>.</p>"},{"location":"parser_spec/#parser-logic_1","title":"Parser Logic","text":"<p>The parser processes input expressions and builds an AST for evaluation by the interpreter (<code>src/interpreter.py</code>). It supports the following features:</p>"},{"location":"parser_spec/#supported-expressions","title":"Supported Expressions","text":"<ul> <li>Number Literals: Parses numeric values (e.g., <code>42</code>, <code>3.14</code>) into <code>NumberNode</code> objects.</li> <li>Arithmetic Operations:</li> <li>Addition (<code>+</code>) and Subtraction (<code>-</code>): Supported as binary operations (e.g., <code>10 + 20</code>, <code>30 - 15</code>).</li> <li>Multiplication (<code>*</code>) and Division (<code>/</code>): Supported as binary operations (e.g., <code>5 * 2</code>, <code>10 / 2</code>).</li> <li>Operations are represented as <code>BinOpNode</code> objects in the AST.</li> <li>Parentheses: Supports nested expressions using parentheses (e.g., <code>(42 + 10) * 2</code>).</li> </ul>"},{"location":"parser_spec/#ast-structure_1","title":"AST Structure","text":"<p>The parser generates an AST using the following node types (defined in <code>src/ast.py</code>): - <code>NumberNode</code>: Represents a numeric literal (e.g., <code>42</code> \u2192 <code>NumberNode(42.0)</code>). - <code>BinOpNode</code>: Represents a binary operation with an operator (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>), left operand, and right operand (e.g., <code>10 + 20</code> \u2192 <code>BinOpNode('+', NumberNode(10.0), NumberNode(20.0))</code>).</p>"},{"location":"parser_spec/#error-handling_1","title":"Error Handling","text":"<ul> <li>The parser uses a custom <code>SyntaxErrorListener</code> to raise exceptions on syntax errors, providing detailed error messages (e.g., \"Syntax error at line 1:5 - missing ';'\").</li> </ul>"},{"location":"parser_spec/#example_1","title":"Example","text":"<p>Input: <code>(42 + 10) * 2</code> - The parser generates an AST:   - Root: <code>BinOpNode('*', ..., ...)</code>   - Left: <code>BinOpNode('+', NumberNode(42.0), NumberNode(10.0))</code>   - Right: <code>NumberNode(2.0)</code></p>"},{"location":"parser_spec/#future-extensions_1","title":"Future Extensions","text":"<ul> <li>Support for variables and assignments (e.g., <code>x = 42</code>).</li> <li>Support for control structures (e.g., <code>if</code>, <code>while</code>).</li> <li>Enhanced error reporting with suggestions.</li> </ul> <p>This document specifies the syntax for the Xyndril language and how the parser should recognize language constructs.</p>"},{"location":"parser_spec/#1-general-syntax","title":"1. General Syntax","text":"<p>Xyndril uses a C-style syntax with curly braces, semicolons, and common operators. The language is designed to be familiar to developers with experience in JavaScript, TypeScript, and similar languages while incorporating unique features for full-stack development.</p>"},{"location":"parser_spec/#2-lexical-structure","title":"2. Lexical Structure","text":""},{"location":"parser_spec/#21-comments","title":"2.1 Comments","text":"<pre><code>// Single-line comment\n\n/* \n   Multi-line\n   comment\n*/\n</code></pre>"},{"location":"parser_spec/#22-literals","title":"2.2 Literals","text":"<pre><code>// Numbers\n42         // Integer\n3.14       // Float\n\n// Strings\n\"hello\"    // Double quotes\n'world'    // Single quotes\n`template ${expression}` // Template string with interpolation\n\n// Booleans\ntrue\nfalse\n\n// Null and undefined\nnull\nundefined\n</code></pre>"},{"location":"parser_spec/#23-identifiers","title":"2.3 Identifiers","text":"<p>Identifiers start with a letter or underscore, followed by any number of letters, digits, or underscores.</p> <pre><code>variableName\n_privateVar\n$element\n</code></pre>"},{"location":"parser_spec/#3-language-constructs","title":"3. Language Constructs","text":""},{"location":"parser_spec/#31-variable-declarations-with-let","title":"3.1 Variable Declarations with <code>let</code>","text":"<pre><code>// Simple declaration\nlet name;\n\n// With initialization\nlet age = 30;\n\n// With type annotation\nlet email: String = \"user@example.com\";\n\n// Multiple declarations\nlet x = 1, y = 2;\n</code></pre> <p>The parser should recognize: - The <code>let</code> keyword - An identifier - Optional type annotation (<code>: TypeName</code>) - Optional initializer (<code>= expression</code>) - Multiple declarations separated by commas</p>"},{"location":"parser_spec/#32-if-statements","title":"3.2 If Statements","text":"<pre><code>// Basic if\nif (condition) {\n  // statements\n}\n\n// If-else\nif (condition) {\n  // statements\n} else {\n  // statements\n}\n\n// If-else if-else\nif (condition1) {\n  // statements\n} else if (condition2) {\n  // statements\n} else {\n  // statements\n}\n</code></pre> <p>The parser should recognize: - The <code>if</code> keyword - A parenthesized condition expression - A block statement for the \"then\" branch - Optional <code>else</code> keyword followed by a block statement or another if statement</p>"},{"location":"parser_spec/#33-arrow-functions","title":"3.3 Arrow Functions","text":"<pre><code>// Simple arrow function\nlet add = (a, b) =&gt; a + b;\n\n// Multi-line arrow function with block\nlet greet = (name) =&gt; {\n  return `Hello, ${name}!`;\n};\n\n// With type annotations\nlet multiply = (x: Number, y: Number): Number =&gt; x * y;\n\n// No parameters\nlet sayHello = () =&gt; \"Hello!\";\n</code></pre> <p>The parser should recognize: - A parameter list (possibly empty) in parentheses - Optional type annotations for parameters - The arrow (<code>=&gt;</code>) token - An expression or block statement for the function body - Optional return type annotation after the parameter list</p>"},{"location":"parser_spec/#34-classes","title":"3.4 Classes","text":"<pre><code>class User {\n  // Properties with type annotations\n  name: String\n  email: String\n  age: Number\n\n  // Constructor\n  constructor(name, email, age) {\n    this.name = name\n    this.email = email\n    this.age = age\n  }\n\n  // Method with return type\n  greet() -&gt; String {\n    return `Hello, I'm ${this.name}!`\n  }\n\n  // Method with parameters\n  updateEmail(newEmail: String) {\n    this.email = newEmail\n  }\n}\n</code></pre> <p>The parser should recognize: - The <code>class</code> keyword followed by an identifier - A class body enclosed in curly braces - Property declarations with optional type annotations - Method declarations with an identifier, parameter list, optional return type, and block body - A special <code>constructor</code> method</p>"},{"location":"parser_spec/#35-rest-routes","title":"3.5 REST Routes","text":"<pre><code>route GET /users {\n  // Return all users\n  return db.getUsers()\n}\n\nroute POST /users {\n  // Create a new user\n  return db.createUser(request.body)\n}\n\nroute GET /users/:id {\n  // Get a specific user\n  return db.getUser(params.id)\n}\n\n// Routes inside classes\nclass UserController {\n  route GET /api/users {\n    return this.getAllUsers()\n  }\n\n  getAllUsers() {\n    // Implementation\n  }\n}\n</code></pre> <p>The parser should recognize: - The <code>route</code> keyword - HTTP method (GET, POST, PUT, DELETE, etc.) - URL path with optional parameters (prefixed with <code>:</code>) - Block body for route handler</p>"},{"location":"parser_spec/#4-expressions","title":"4. Expressions","text":""},{"location":"parser_spec/#41-binary-operators","title":"4.1 Binary Operators","text":"<p>Standard arithmetic, comparison, and logical operators:</p> <pre><code>// Arithmetic\na + b\na - b\na * b\na / b\na % b\n\n// Comparison\na == b\na != b\na &lt; b\na &lt;= b\na &gt; b\na &gt;= b\n\n// Logical\na &amp;&amp; b\na || b\n</code></pre>"},{"location":"parser_spec/#42-unary-operators","title":"4.2 Unary Operators","text":"<pre><code>-a      // Negation\n!a      // Logical NOT\na++     // Increment\na--     // Decrement\n</code></pre>"},{"location":"parser_spec/#43-function-calls","title":"4.3 Function Calls","text":"<pre><code>print(\"Hello\")\nuser.getName()\nMath.max(1, 2, 3)\n</code></pre>"},{"location":"parser_spec/#44-member-access","title":"4.4 Member Access","text":"<pre><code>user.name\narray[0]\n</code></pre>"},{"location":"parser_spec/#5-statements","title":"5. Statements","text":""},{"location":"parser_spec/#51-return-statements","title":"5.1 Return Statements","text":"<pre><code>return;\nreturn value;\n</code></pre>"},{"location":"parser_spec/#52-expression-statements","title":"5.2 Expression Statements","text":"<p>Any expression can be used as a statement:</p> <pre><code>foo();\na = b + c;\nx++;\n</code></pre>"},{"location":"parser_spec/#6-program-structure","title":"6. Program Structure","text":"<p>A Xyndril program consists of a sequence of statements and declarations at the top level:</p> <pre><code>// Imports (future feature)\nimport { Component } from 'library'\n\n// Variable declarations\nlet config = {\n  port: 3000\n}\n\n// Function declarations\nlet start = () =&gt; {\n  // Implementation\n}\n\n// Class declarations\nclass App {\n  // Implementation\n}\n\n// Route declarations\nroute GET / {\n  return \"Hello, World!\"\n}\n\n// Main code\nstart()\n</code></pre>"},{"location":"parser_spec/#7-parsing-strategy","title":"7. Parsing Strategy","text":"<p>The parser should follow these steps:</p> <ol> <li>Tokenize the input into a stream of tokens</li> <li>Build a recursive descent parser that recognizes the language constructs</li> <li>Construct an AST according to the structure defined in <code>ast.cld.py</code></li> <li>Handle error cases with informative error messages</li> </ol> <p>The parser should be designed to be extensible for future language features.</p>"},{"location":"project-status/","title":"Project Status: Xyndril-lang","text":"<p>This document summarizes which components of the Xyndril-lang project are implemented, which are incomplete, and their current state, based on the actual codebase.</p>"},{"location":"project-status/#implemented-components","title":"Implemented Components","text":"<ul> <li>Tokenizer (<code>parser/tokenizer.py</code>):</li> <li>Fully implemented. Tokenizes code into tokens using regular expressions.</li> <li>Parser (<code>parser/parser.py</code>):</li> <li>Minimal implementation. Calls tokenizer and wraps tokens as a skeleton AST. No full parsing logic yet.</li> <li>AST Definitions (<code>src/ast.py</code>, <code>docs/ast.cld.py</code>):</li> <li>Implemented. Defines AST node classes.</li> <li>Interpreter (<code>src/interpreter.py</code>, <code>docs/interpreter.cld.py</code>):</li> <li>Implemented. Evaluates AST nodes and supports variable environments.</li> <li>REPL (<code>src/repl.py</code>):</li> <li>Implemented as a basic Python-based REPL for AST node evaluation. Uses a dummy parser for now.</li> <li>Manifest/Specs (<code>design/xyndril-manifest.md</code>, <code>docs/xyndril-manifest.md</code>, <code>docs/language-spec.md</code>, <code>docs/parser_spec.md</code>):</li> <li>Implemented. Contains design, language, and parser specifications.</li> <li>Examples (<code>examples/hello.nx</code>, <code>docs/examples/</code>):</li> <li>Present. Contains example Xyndril code.</li> <li>Runtime (<code>interpreter/runtime.py</code>):</li> <li>Present. Interpreter runtime support.</li> <li>Documentation (<code>README.md</code>, <code>docs/</code>, <code>docs_sphinx/</code>):</li> <li>Extensive documentation and Sphinx setup.</li> </ul>"},{"location":"project-status/#incomplete-or-placeholder-components","title":"Incomplete or Placeholder Components","text":"<ul> <li>REPL (xyndril-kit/src/repl.py):</li> <li>Placeholder only. Not implemented.</li> <li>Parser (full logic):</li> <li>Only skeleton logic exists. No full grammar parsing or AST construction.</li> <li>Server: Not present.</li> <li>Tests: No dedicated tests or test/ directory found.</li> <li>Manifest (xyndril-manifest as config file): No dedicated manifest config file present, only markdown manifests.</li> <li>Tooling (<code>tools/</code>):</li> <li>Directory exists but is empty.</li> </ul>"},{"location":"project-status/#roadmap-comparison-todos","title":"Roadmap Comparison / TODOs","text":"<ul> <li>Lexer/Tokenizer: Done</li> <li>Parser: Skeleton only</li> <li>Interpreter: Done</li> <li>REPL: Basic version done, full version placeholder</li> <li>Server: Missing</li> <li>Tests: Missing</li> <li>Examples: Present</li> <li>Documentation: Extensive</li> </ul>"},{"location":"project-status/#notable-issues","title":"Notable Issues","text":"<ul> <li>Some files (e.g., <code>src/repl.py</code>, <code>xyndril-kit/src/repl.py</code>) are placeholders or incomplete.</li> <li>No automated tests or test suite detected.</li> <li>No server or network components implemented.</li> <li>Some specifications exist only as markdown, not as code/config.</li> </ul> <p>This status is based strictly on the current project contents. No assumptions are made about missing or planned features beyond what is present in the codebase.</p>"},{"location":"project-structure/","title":"Project Structure: Xyndril-lang","text":"<p>This document provides a detailed listing of the directories and files in the Xyndril-lang project (max depth: 3), with a brief description of each.</p>"},{"location":"project-structure/#root-directory","title":"Root Directory","text":"<ul> <li><code>.git/</code> \u2014 Git version control directory.</li> <li><code>.gitignore</code> \u2014 Specifies files ignored by Git.</li> <li><code>.venv/</code> \u2014 Python virtual environment.</li> <li><code>README-agent.txt</code> \u2014 Agent-specific readme.</li> <li><code>README.md</code> \u2014 Main project readme.</li> <li><code>WORKSPACE_SETUP.md</code> \u2014 Workspace setup instructions.</li> <li><code>cli/</code> \u2014 CLI entry point for Xyndril.</li> <li><code>design/</code> \u2014 Design documents.</li> <li><code>docs/</code> \u2014 Project documentation and specifications.</li> <li><code>docs_sphinx/</code> \u2014 Sphinx documentation build and source.</li> <li><code>examples/</code> \u2014 Example Xyndril source files.</li> <li><code>interpreter/</code> \u2014 Interpreter runtime code.</li> <li><code>ohjeet.txt</code> \u2014 Project instructions (in Finnish).</li> <li><code>parser/</code> \u2014 Parser and tokenizer modules.</li> <li><code>raportti.md</code> \u2014 Report file (in Finnish).</li> <li><code>site/</code> \u2014 Static site output (possibly for docs).</li> <li><code>src/</code> \u2014 Main source code (AST, interpreter, REPL).</li> <li><code>tasks.json</code> \u2014 Task definitions/configuration.</li> <li><code>tools/</code> \u2014 (Empty) Tools directory.</li> <li><code>xyndril-kit/</code> \u2014 Project meta files and agent guidelines.</li> <li><code>xyndril.code-workspace</code> \u2014 VS Code workspace file.</li> </ul>"},{"location":"project-structure/#key-subdirectories-and-files","title":"Key Subdirectories and Files","text":""},{"location":"project-structure/#cli","title":"cli/","text":"<ul> <li><code>xyndril.py</code> \u2014 CLI entry point script.</li> </ul>"},{"location":"project-structure/#design","title":"design/","text":"<ul> <li><code>xyndril-manifest.md</code> \u2014 Manifest and design notes.</li> </ul>"},{"location":"project-structure/#docs","title":"docs/","text":"<ul> <li><code>CNAME</code> \u2014 Custom domain for documentation site.</li> <li><code>ast.cld.py</code> \u2014 AST class definitions (Python).</li> <li><code>examples/</code> \u2014 Example files for documentation.</li> <li><code>index.md</code> \u2014 Documentation index.</li> <li><code>instructions.txt</code> \u2014 Additional instructions.</li> <li><code>interpreter.cld.py</code> \u2014 Interpreter class definitions (Python).</li> <li><code>language-spec.md</code> \u2014 Language specification.</li> <li><code>parser_spec.md</code> \u2014 Parser specification.</li> <li><code>usage.md</code> \u2014 Usage instructions.</li> <li><code>workspace-setup.md</code> \u2014 Workspace setup for docs.</li> <li><code>xyndril-manifest.md</code> \u2014 Manifest for docs.</li> <li><code>xyndril.g4</code> \u2014 ANTLR grammar file.</li> </ul>"},{"location":"project-structure/#docs_sphinx","title":"docs_sphinx/","text":"<ul> <li><code>Makefile</code> \u2014 Sphinx build script.</li> <li><code>build/</code> \u2014 Sphinx build output.</li> <li><code>source/</code> \u2014 Sphinx documentation sources.</li> </ul>"},{"location":"project-structure/#examples","title":"examples/","text":"<ul> <li><code>hello.nx</code> \u2014 Example Xyndril code.</li> </ul>"},{"location":"project-structure/#interpreter","title":"interpreter/","text":"<ul> <li><code>runtime.py</code> \u2014 Interpreter runtime support.</li> </ul>"},{"location":"project-structure/#parser","title":"parser/","text":"<ul> <li><code>parser.py</code> \u2014 Parser implementation (calls tokenizer, returns AST skeleton).</li> <li><code>tokenizer.py</code> \u2014 Tokenizer implementation (tokenizes code into tokens).</li> </ul>"},{"location":"project-structure/#src","title":"src/","text":"<ul> <li><code>ast.py</code> \u2014 AST node definitions.</li> <li><code>interpreter.py</code> \u2014 Interpreter implementation (evaluates AST).</li> <li><code>repl.py</code> \u2014 Read-Eval-Print Loop (REPL) for Xyndril.</li> </ul>"},{"location":"project-structure/#xyndril-kit","title":"xyndril-kit/","text":"<ul> <li><code>CHANGELOG.md</code> \u2014 Project changelog.</li> <li><code>PROJECT_INTRO.md</code> \u2014 Project introduction.</li> <li><code>agent-guidelines.md</code> \u2014 Agent guidelines.</li> <li><code>src/repl.py</code> \u2014 Placeholder for REPL (not yet implemented).</li> <li><code>tasks.template.json</code> \u2014 Task template configuration.</li> </ul>"},{"location":"project-structure/#tools","title":"tools/","text":"<ul> <li>(Empty)</li> </ul> <p>Descriptions are based on actual file contents and structure. Placeholder or empty files are not listed unless they serve a clear structural purpose.</p>"},{"location":"usage/","title":"Xyndril Usage Guide","text":"<p>This section will contain instructions for using the Xyndril language and its tools.</p>"},{"location":"workspace-setup/","title":"Workspace Setup","text":"<p>This page describes how to set up the Xyndril programming language development environment.</p>"},{"location":"workspace-setup/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10+</li> <li>Git</li> <li>(Optional) VS Code or Windsurf Editor</li> </ul>"},{"location":"workspace-setup/#installation","title":"Installation","text":"<ol> <li>Clone the repository:    <code>sh    git clone https://github.com/maaninentupee/xyndril-kit.git    cd xyndril-kit</code></li> <li>Create and activate a virtual environment:    <code>sh    python3 -m venv .venv    source .venv/bin/activate</code></li> <li>Install dependencies:    <code>sh    pip install -r requirements.txt</code></li> </ol>"},{"location":"workspace-setup/#running-the-documentation-site","title":"Running the Documentation Site","text":"<p>To preview the documentation locally:</p> <pre><code>mkdocs serve\n</code></pre> <p>Site will be available at http://localhost:8000</p>"},{"location":"workspace-setup/#notes","title":"Notes","text":"<ul> <li>Only files in the <code>docs/</code> folder are published to the documentation site.</li> <li>Do not edit or move files in <code>design/</code>, <code>parser/</code>, or <code>ohjeet.txt</code> unless instructed.</li> </ul>"},{"location":"xyndril-manifest/","title":"Xyndril Manifest (Technical Vision)","text":""},{"location":"xyndril-manifest/#what-is-xyndril","title":"\u2728 What is Xyndril?","text":"<p>Xyndril is an experimental full-stack programming language designed to unify frontend, backend, and AI logic into a seamless development experience.</p> <p>Unlike traditional stacks where developers must switch between multiple languages and tools (JavaScript, Python, OpenAI SDKs), Xyndril proposes a polyglot-compatible architecture: it is designed to work alongside other languages and tools, eliminating friction between layers while enabling optional unification through a shared syntax.</p>"},{"location":"xyndril-manifest/#philosophy","title":"\ud83d\udd20 Philosophy","text":"<p>\"One language to rule every layer \u2014 when you want it to\"</p> <ul> <li>Readable and extensible syntax</li> <li>Lightweight typing with optional static types</li> <li>AI features embedded into the language core</li> <li>Native support for API routing and UI components</li> <li>Interop-first mindset: Xyndril can both stand alone or integrate with your existing stack</li> </ul>"},{"location":"xyndril-manifest/#key-differentiators","title":"\ud83d\udca1 Key Differentiators","text":"Feature Xyndril Other Languages Full-stack support \u2705 Unified syntax, optional adoption \u274c Separated frontend/backend AI integration \u2705 Native syntax-level support \u274c External libs required REST routes \u2705 Built-in routing \u274c Defined in frameworks UI components \u2705 (Planned) as native syntax \u274c Framework-dependent Interop support \u2705 Designed for multi-language use \u26a0\ufe0f Often secondary concern"},{"location":"xyndril-manifest/#version-001-features","title":"\ud83d\ude80 Version 0.0.1 Features","text":"<ul> <li>print() command</li> <li>class keyword for defining objects</li> <li>fn for methods</li> <li>route GET /path =&gt; { ... } \u2014 native REST routing</li> <li>let statements</li> <li>Arrow functions: let add = (a, b) =&gt; a + b</li> <li>Conditional logic with if/else</li> <li>\u2728 AI Command: ai.prompt(\"...\") (planned v0.0.2)</li> </ul>"},{"location":"xyndril-manifest/#syntax-example","title":"\ud83d\udd22 Syntax Example","text":"<pre><code>// Class definition\nclass User {\n  name: String\n  email: String\n  age: Number\n\n  constructor(name, email, age) {\n    this.name = name\n    this.email = email\n    this.age = age\n  }\n\n  greet() -&gt; String {\n    return \"Hello, I'm ${this.name}!\"\n  }\n\n  route GET /user/:id {\n    return this\n  }\n}\n\n// Functional style\nlet double = (x: Number) -&gt; Number =&gt; x * 2\nlet add = (a, b) =&gt; a + b\n\n// Conditional logic\nif (user.age &gt;= 18) {\n  console.log(\"Adult\")\n} else {\n  console.log(\"Minor\")\n}\n\n// Higher-order functions\nlet adults = users\n  .filter(user =&gt; user.age &gt;= 18)\n  .map(user =&gt; user.name)\n</code></pre>"},{"location":"xyndril-manifest/#runtime-architecture-planned","title":"\ud83d\udea7 Runtime Architecture (Planned)","text":"<p>Memory Management: - Static analysis of variables at compile time - Stack allocation for primitives - Heap with generational GC for complex types - Region-based memory zones for task-specific speed</p> <p>Garbage Collection Strategy: - Generational GC - Concurrent execution - Incremental marking - Region-based optimization</p> <p>State Synchronization: - Realtime sync between client and server - Reactive dataflow model planned</p>"},{"location":"xyndril-manifest/#vision","title":"\ud83c\udf0d Vision","text":"<p>Xyndril is not just a new syntax. It is an attempt to create a cohesive, AI-native programming world where API logic, UI elements, and AI behavior can all be expressed in one language \u2014 without excluding others.</p> <p>One language. Unified syntax. Interoperable by design.</p> <p>Xyndril empowers developers to choose how deeply they adopt it: as a single-language full-stack platform, a language for AI agent workflows, or a flexible interop layer alongside existing systems.</p>"},{"location":"xyndril-manifest/#technical-spec-roadmap","title":"\ud83d\udcda Technical Spec Roadmap","text":"Design Files (Claude) Refactored Code (GPT) design/ast.cld.py \u2192 src/ast.py design/interpreter.cld.py \u2192 src/interpreter.py design/parser_spec.md \u2192 parser/xyndril.g4 (REPL Design) \u2192 src/repl.py <p>Design files are used as a planning layer, and refactoring is done by GPT for final integration into the compiler.</p>"},{"location":"xyndril-manifest/#see-also","title":"\ud83d\udd0d See Also","text":"<ul> <li>GitHub Repository</li> <li>\ud83d\udcd6 See the full project overview in the README on GitHub</li> </ul>"}]}